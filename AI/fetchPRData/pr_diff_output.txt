Processing programs/casier/src/lib.rs...

--- BEFORE CODE (from parent commit) ---
pub mod state;
pub mod utils;

use crate::state::{ErrorCode, *};
use crate::utils::*;
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{pubkey::Pubkey, rent::Rent};
use anchor_spl;

// declare_id!("CAsieqooSrgVxhgWRwh21gyjq7Rmuhmo4qTW9XzXtAvW");
declare_id!("FLoc9nBwGb2ayzVzb5GC9NttuPY3CxMhd4KDnApr79Ab");

#[program]
pub mod casier {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }

    pub fn init_config(ctx: Context<InitConfig>) -> Result<()> {
        ctx.accounts.config.admin = ctx.accounts.fee_payer.key();
        ctx.accounts.config.is_frozen = false;
        Ok(())
    }

    pub fn init_locker(ctx: Context<InitLocker>, _space: u64) -> Result<()> {
        ctx.accounts.locker.owner = ctx.accounts.owner.key();
        ctx.accounts.locker.space = ctx.accounts.locker.to_account_info().data_len() as u64;
        Ok(())
    }

    pub fn increase_locker_size(ctx: Context<IncreaseLockerSize>, _new_size: u64) -> Result<()> {
        Ok(())
    }

    /*
     * Deposits deposit_amount into the vault if the current mint's amount in the locker is before_amount.
     * burn_ta is an admin controlled TA
     */
    pub fn deposit<'a, 'b, 'c, 'info>(
        ctx: Context<'a, 'b, 'c, 'info, Deposit>,
        vault_bump: u8,
        deposit_amount: u64,
        before_amount: u64,
        burn_bump: u8,
        should_go_in_burn_ta: bool,
    ) -> Result<()> {
        let locker = &mut ctx.accounts.locker;
        let mk = ctx.accounts.mint.key();
        match locker.mints.iter().position(|&lm| lm == mk) {
            None => {
                if before_amount > 0 {
                    return Err(error!(ErrorCode::InvalidBeforeState));
                }
                locker.mints.push(mk);
                locker.amounts.push(deposit_amount);
            }
            Some(i) => {
                if before_amount != locker.amounts[i] {
                    return Err(error!(ErrorCode::InvalidBeforeState2));
                }
                locker.amounts[i] += deposit_amount;
            }
        }
        if should_go_in_burn_ta {
            if *(ctx.accounts.burn_ta.to_account_info().owner) != ctx.accounts.token_program.key() {
                let vault_account_seeds = &[
                    ctx.accounts.mint.to_account_info().key.as_ref(),
                    &[burn_bump],
                ];
                let vault_account_signer = &vault_account_seeds[..];
                // initialize nft vault account
                spl_init_token_account(InitializeTokenAccountParams {
                    account: ctx.accounts.burn_ta.to_account_info(),
                    account_signer_seeds: vault_account_signer,
                    mint: ctx.accounts.mint.to_account_info(),
                    owner: ctx.accounts.burn_ta.to_account_info(),
                    payer: ctx.accounts.owner.to_account_info(),
                    system_program: ctx.accounts.system_program.to_account_info(),
                    token_program: ctx.accounts.token_program.to_account_info(),
                    rent: ctx.accounts.rent.to_account_info(),
                })?;
            }
        } else {
            if *(ctx.accounts.vault_ta.to_account_info().owner) != ctx.accounts.token_program.key()
            {
                let vault_account_seeds = &[
                    ctx.accounts.mint.to_account_info().key.as_ref(),
                    ctx.accounts.owner.key.as_ref(),
                    &[vault_bump],
                ];
                let vault_account_signer = &vault_account_seeds[..];

                // initialize nft vault account
                spl_init_token_account(InitializeTokenAccountParams {
                    account: ctx.accounts.vault_ta.to_account_info(),
                    account_signer_seeds: vault_account_signer,
                    mint: ctx.accounts.mint.to_account_info(),
                    owner: ctx.accounts.vault_ta.to_account_info(),
                    payer: ctx.accounts.owner.to_account_info(),
                    system_program: ctx.accounts.system_program.to_account_info(),
                    token_program: ctx.accounts.token_program.to_account_info(),
                    rent: ctx.accounts.rent.to_account_info(),
                })?;
            }
        }

        let mut dest_ta = match should_go_in_burn_ta {
            true => Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.burn_ta.to_account_info(),
            )?,
            false => Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.vault_ta.to_account_info(),
            )?,
        };
        let is_valid_dest =
            dest_ta.owner == dest_ta.key() && dest_ta.mint == ctx.accounts.mint.key();

        if !is_valid_dest {
            return Err(error!(ErrorCode::InvalidVault));
        }

        spl_token_transfer(TokenTransferParams {
            source: ctx.accounts.user_ta.to_account_info(),
            destination: dest_ta.to_account_info(),
            amount: deposit_amount.into(),
            authority: ctx.accounts.owner.to_account_info(),
            authority_signer_seeds: &[],
            token_program: ctx.accounts.token_program.to_account_info(),
        })?;

        let vault_lamports = **ctx.accounts.vault_ta.try_borrow_mut_lamports()?;
        if should_go_in_burn_ta && vault_lamports > 0 {
            let vault_ta = Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.vault_ta.to_account_info(),
            )?;
            if vault_ta.amount > 0 {
                anchor_spl::token::transfer(
                    CpiContext::new_with_signer(
                        ctx.accounts.token_program.to_account_info(),
                        anchor_spl::token::Transfer {
                            from: ctx.accounts.vault_ta.to_account_info(),
                            to: dest_ta.to_account_info(),
                            authority: ctx.accounts.vault_ta.to_account_info(),
                        },
                        &[&[
                            ctx.accounts.mint.key().as_ref(),
                            ctx.accounts.locker.owner.key().as_ref(),
                            &[vault_bump],
                        ]],
                    ),
                    vault_ta.amount.into(),
                )?;
                anchor_spl::token::close_account(CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::CloseAccount {
                        account: ctx.accounts.vault_ta.to_account_info(),
                        destination: ctx.accounts.owner.to_account_info(),
                        authority: ctx.accounts.vault_ta.to_account_info(),
                    },
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        ctx.accounts.locker.owner.key().as_ref(),
                        &[vault_bump],
                    ]],
                ))?;
            }
        }

        Ok(())
    }

    pub fn withdraw_v2<'a, 'b, 'c, 'info>(
        ctx: Context<'a, 'b, 'c, 'info, WithdrawV2>,
        vault_bump: u8,
        burn_bump: u8,
        withdraw_amount: u64,
        before_amount: u64,
        final_amount: u64,
    ) -> Result<()> {
        let locker = &mut ctx.accounts.locker;
        let mk = ctx.accounts.mint.key();
        let mint_position_option = locker.mints.iter().position(|&lm| lm == mk);

        if let None = mint_position_option {
            return Err(error!(ErrorCode::WithdrawForMintNotInLocker));
        }

        let withdraw_from_burner_ta = ctx.accounts.vault_ta.key() == ctx.accounts.burn_ta.key();
        let mut sourceTa = match withdraw_from_burner_ta {
            true => Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.burn_ta.to_account_info(),
            )?,
            false => Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.vault_ta.to_account_info(),
            )?,
        };
        if sourceTa.amount < withdraw_amount {
            return Err(error!(ErrorCode::InsufficientFunds));
        }

        let mint_position = mint_position_option.unwrap();

        let withdraw_type = get_withdraw_type(
            locker,
            ctx.accounts.user_ta_owner.key(),
            final_amount,
            sourceTa.amount,
            withdraw_amount,
        );

        // Check if locker.amounts[i] is equal to before_amount to avoid duplicates
        if locker.amounts[mint_position] != before_amount {
            return Err(error!(ErrorCode::InvalidBeforeState));
        }

        if final_amount > 0 {
            locker.amounts[mint_position] = final_amount;
        } else {
            locker.mints.remove(mint_position);
            locker.amounts.remove(mint_position);
        }

        if *ctx.accounts.user_ta.to_account_info().owner != ctx.accounts.token_program.key() {
            let cpi_program = ctx.accounts.associated_token_program.to_account_info();
            let cpi_accounts = anchor_spl::associated_token::Create {
                payer: ctx.accounts.user_ta_owner.to_account_info(),
                associated_token: ctx.accounts.user_ta.to_account_info(),
                authority: ctx.accounts.user_ta_owner.to_account_info(),
                mint: ctx.accounts.mint.to_account_info(),
                system_program: ctx.accounts.system_program.to_account_info(),
                token_program: ctx.accounts.token_program.to_account_info(),
                rent: ctx.accounts.rent.to_account_info(),
            };
            let cpi_ctx = anchor_lang::context::CpiContext::new(cpi_program, cpi_accounts);
            anchor_spl::associated_token::create(cpi_ctx)?;
        }

        if withdraw_from_burner_ta {
            anchor_spl::token::transfer(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::Transfer {
                        from: ctx.accounts.vault_ta.to_account_info(),
                        to: ctx.accounts.user_ta.to_account_info(),
                        authority: ctx.accounts.vault_ta.to_account_info(),
                    },
                    &[&[ctx.accounts.mint.key().as_ref(), &[vault_bump]]],
                ),
                withdraw_amount.into(),
            )?;
        } else {
            anchor_spl::token::transfer(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::Transfer {
                        from: ctx.accounts.vault_ta.to_account_info(),
                        to: ctx.accounts.user_ta.to_account_info(),
                        authority: ctx.accounts.vault_ta.to_account_info(),
                    },
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        ctx.accounts.locker.owner.key().as_ref(),
                        &[vault_bump],
                    ]],
                ),
                withdraw_amount.into(),
            )?;
        }

        // check if withdraw_type is WithdrawType::OwnerBurn or WithdrawType::NonOwnerBurn
        if matches!(
            withdraw_type,
            WithdrawType::OwnerBurn | WithdrawType::NonOwnerBurn
        ) && ctx.accounts.vault_ta.key() != ctx.accounts.burn_ta.key()
        {
            if *(ctx.accounts.burn_ta.to_account_info().owner) != ctx.accounts.token_program.key() {
                let mc = &ctx.accounts.mint.clone();
                let pk = &mc.key().clone();
                let pkr = pk.as_ref();

                let vault_account_seeds = &[pkr, &[burn_bump]];
                let vault_account_signer = &vault_account_seeds[..];

                // initialize nft vault account
                spl_init_token_account(InitializeTokenAccountParams {
                    account: ctx.accounts.burn_ta.to_account_info(),
                    account_signer_seeds: vault_account_signer,
                    mint: ctx.accounts.mint.to_account_info(),
                    owner: ctx.accounts.burn_ta.to_account_info(),
                    payer: ctx.accounts.user_ta_owner.to_account_info(),
                    system_program: ctx.accounts.system_program.to_account_info(),
                    token_program: ctx.accounts.token_program.to_account_info(),
                    rent: ctx.accounts.rent.to_account_info(),
                })?;
            }
            anchor_spl::token::transfer(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::Transfer {
                        from: ctx.accounts.vault_ta.to_account_info(),
                        to: ctx.accounts.burn_ta.to_account_info(),
                        authority: ctx.accounts.vault_ta.to_account_info(),
                    },
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        ctx.accounts.locker.owner.key().as_ref(),
                        &[vault_bump],
                    ]],
                ),
                sourceTa.amount - final_amount,
            )?;
        }

        sourceTa.reload()?;
        if sourceTa.amount == 0 && !withdraw_from_burner_ta {
            anchor_spl::token::close_account(CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::CloseAccount {
                    account: ctx.accounts.vault_ta.to_account_info(),
                    destination: ctx.accounts.vault_ta_owner.to_account_info(),
                    authority: ctx.accounts.vault_ta.to_account_info(),
                },
                &[&[
                    ctx.accounts.mint.key().as_ref(),
                    ctx.accounts.vault_ta_owner.key().as_ref(),
                    &[vault_bump],
                ]],
            ))?;
        }

        Ok(())
    }
}


--- AFTER CODE (from current commit) ---
pub mod state;
pub mod utils;

use crate::state::{ErrorCode, *};
use crate::utils::*;
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{pubkey::Pubkey, rent::Rent};
use anchor_spl;

// declare_id!("CAsieqooSrgVxhgWRwh21gyjq7Rmuhmo4qTW9XzXtAvW");
declare_id!("FLoc9nBwGb2ayzVzb5GC9NttuPY3CxMhd4KDnApr79Ab");

#[program]
pub mod casier {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        Ok(())
    }

    pub fn init_config(ctx: Context<InitConfig>) -> Result<()> {
        ctx.accounts.config.admin = ctx.accounts.fee_payer.key();
        ctx.accounts.config.is_frozen = false;
        Ok(())
    }

    pub fn init_locker(ctx: Context<InitLocker>, _space: u64) -> Result<()> {
        ctx.accounts.locker.owner = ctx.accounts.owner.key();
        ctx.accounts.locker.space = ctx.accounts.locker.to_account_info().data_len() as u64;
        Ok(())
    }

    pub fn increase_locker_size(ctx: Context<IncreaseLockerSize>, _new_size: u64) -> Result<()> {
        Ok(())
    }

    /*
     * Deposits deposit_amount into the vault if the current mint's amount in the locker is before_amount.
     * burn_ta is an admin controlled TA
     */
    pub fn deposit<'a, 'b, 'c, 'info>(
        ctx: Context<'a, 'b, 'c, 'info, Deposit>,
        vault_bump: u8,
        deposit_amount: u64,
        before_amount: u64,
        burn_bump: u8,
        should_go_in_burn_ta: bool,
    ) -> Result<()> {
        let locker = &mut ctx.accounts.locker;
        let mk = ctx.accounts.mint.key();
        match locker.mints.iter().position(|&lm| lm == mk) {
            None => {
                if before_amount > 0 {
                    return Err(error!(ErrorCode::InvalidBeforeState));
                }
                locker.mints.push(mk);
                locker.amounts.push(deposit_amount);
            }
            Some(i) => {
                if before_amount != locker.amounts[i] {
                    return Err(error!(ErrorCode::InvalidBeforeState2));
                }
                locker.amounts[i] += deposit_amount;
            }
        }
        if should_go_in_burn_ta {
            if *(ctx.accounts.burn_ta.to_account_info().owner) != ctx.accounts.token_program.key() {
                let vault_account_seeds = &[
                    ctx.accounts.mint.to_account_info().key.as_ref(),
                    &[burn_bump],
                ];
                let vault_account_signer = &vault_account_seeds[..];
                // initialize nft vault account
                spl_init_token_account(InitializeTokenAccountParams {
                    account: ctx.accounts.burn_ta.to_account_info(),
                    account_signer_seeds: vault_account_signer,
                    mint: ctx.accounts.mint.to_account_info(),
                    owner: ctx.accounts.burn_ta.to_account_info(),
                    payer: ctx.accounts.owner.to_account_info(),
                    system_program: ctx.accounts.system_program.to_account_info(),
                    token_program: ctx.accounts.token_program.to_account_info(),
                    rent: ctx.accounts.rent.to_account_info(),
                })?;
            }
        } else {
            if *(ctx.accounts.vault_ta.to_account_info().owner) != ctx.accounts.token_program.key()
            {
                let vault_account_seeds = &[
                    ctx.accounts.mint.to_account_info().key.as_ref(),
                    ctx.accounts.owner.key.as_ref(),
                    &[vault_bump],
                ];
                let vault_account_signer = &vault_account_seeds[..];

                // initialize nft vault account
                spl_init_token_account(InitializeTokenAccountParams {
                    account: ctx.accounts.vault_ta.to_account_info(),
                    account_signer_seeds: vault_account_signer,
                    mint: ctx.accounts.mint.to_account_info(),
                    owner: ctx.accounts.vault_ta.to_account_info(),
                    payer: ctx.accounts.owner.to_account_info(),
                    system_program: ctx.accounts.system_program.to_account_info(),
                    token_program: ctx.accounts.token_program.to_account_info(),
                    rent: ctx.accounts.rent.to_account_info(),
                })?;
            }
        }

        let mut dest_ta = match should_go_in_burn_ta {
            true => Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.burn_ta.to_account_info(),
            )?,
            false => Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.vault_ta.to_account_info(),
            )?,
        };
        let is_valid_dest =
            dest_ta.owner == dest_ta.key() && dest_ta.mint == ctx.accounts.mint.key();

        if !is_valid_dest {
            return Err(error!(ErrorCode::InvalidVault));
        }

        spl_token_transfer(TokenTransferParams {
            source: ctx.accounts.user_ta.to_account_info(),
            destination: dest_ta.to_account_info(),
            amount: deposit_amount.into(),
            authority: ctx.accounts.owner.to_account_info(),
            authority_signer_seeds: &[],
            token_program: ctx.accounts.token_program.to_account_info(),
        })?;

        let vault_lamports = **ctx.accounts.vault_ta.try_borrow_mut_lamports()?;
        if should_go_in_burn_ta && vault_lamports > 0 {
            let vault_ta = Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.vault_ta.to_account_info(),
            )?;
            if vault_ta.amount > 0 {
                anchor_spl::token::transfer(
                    CpiContext::new_with_signer(
                        ctx.accounts.token_program.to_account_info(),
                        anchor_spl::token::Transfer {
                            from: ctx.accounts.vault_ta.to_account_info(),
                            to: dest_ta.to_account_info(),
                            authority: ctx.accounts.vault_ta.to_account_info(),
                        },
                        &[&[
                            ctx.accounts.mint.key().as_ref(),
                            ctx.accounts.locker.owner.key().as_ref(),
                            &[vault_bump],
                        ]],
                    ),
                    vault_ta.amount.into(),
                )?;
                anchor_spl::token::close_account(CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::CloseAccount {
                        account: ctx.accounts.vault_ta.to_account_info(),
                        destination: ctx.accounts.owner.to_account_info(),
                        authority: ctx.accounts.vault_ta.to_account_info(),
                    },
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        ctx.accounts.locker.owner.key().as_ref(),
                        &[vault_bump],
                    ]],
                ))?;
            }
        }

        Ok(())
    }

    pub fn withdraw_v2<'a, 'b, 'c, 'info>(
        ctx: Context<'a, 'b, 'c, 'info, WithdrawV2>,
        vault_bump: u8,
        burn_bump: u8,
        withdraw_amount: u64,
        before_amount: u64,
        final_amount: u64,
    ) -> Result<()> {
        let locker = &mut ctx.accounts.locker;
        let mk = ctx.accounts.mint.key();
        let mint_position_option = locker.mints.iter().position(|&lm| lm == mk);

        if let None = mint_position_option {
            return Err(error!(ErrorCode::WithdrawForMintNotInLocker));
        }

        let withdraw_from_burner_ta = ctx.accounts.vault_ta.key() == ctx.accounts.burn_ta.key();
        let mut sourceTa = match withdraw_from_burner_ta {
            true => Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.burn_ta.to_account_info(),
            )?,
            false => Account::<'_, anchor_spl::token::TokenAccount>::try_from(
                &ctx.accounts.vault_ta.to_account_info(),
            )?,
        };
        if sourceTa.amount < withdraw_amount {
            return Err(error!(ErrorCode::InsufficientFunds));
        }

        let mint_position = mint_position_option.unwrap();

        let withdraw_type = get_withdraw_type(
            locker,
            ctx.accounts.user_ta_owner.key(),
            final_amount,
            sourceTa.amount,
            withdraw_amount,
        );

        // Check if locker.amounts[i] is equal to before_amount to avoid duplicates
        if locker.amounts[mint_position] != before_amount {
            return Err(error!(ErrorCode::InvalidBeforeState));
        }

        if final_amount > 0 {
            locker.amounts[mint_position] = final_amount;
        } else {
            locker.mints.remove(mint_position);
            locker.amounts.remove(mint_position);
        }

        if *ctx.accounts.user_ta.to_account_info().owner != ctx.accounts.token_program.key() {
            let cpi_program = ctx.accounts.associated_token_program.to_account_info();
            let cpi_accounts = anchor_spl::associated_token::Create {
                payer: ctx.accounts.user_ta_owner.to_account_info(),
                associated_token: ctx.accounts.user_ta.to_account_info(),
                authority: ctx.accounts.user_ta_owner.to_account_info(),
                mint: ctx.accounts.mint.to_account_info(),
                system_program: ctx.accounts.system_program.to_account_info(),
                token_program: ctx.accounts.token_program.to_account_info(),
                rent: ctx.accounts.rent.to_account_info(),
            };
            let cpi_ctx = anchor_lang::context::CpiContext::new(cpi_program, cpi_accounts);
            anchor_spl::associated_token::create(cpi_ctx)?;
        }

        if withdraw_from_burner_ta {
            anchor_spl::token::transfer(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::Transfer {
                        from: ctx.accounts.burn_ta.to_account_info(),
                        to: ctx.accounts.user_ta.to_account_info(),
                        authority: ctx.accounts.burn_ta.to_account_info(),
                    },
                    &[&[ctx.accounts.mint.key().as_ref(), &[burn_bump]]],
                ),
                withdraw_amount.into(),
            )?;
        } else {
            anchor_spl::token::transfer(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::Transfer {
                        from: ctx.accounts.vault_ta.to_account_info(),
                        to: ctx.accounts.user_ta.to_account_info(),
                        authority: ctx.accounts.vault_ta.to_account_info(),
                    },
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        ctx.accounts.locker.owner.key().as_ref(),
                        &[vault_bump],
                    ]],
                ),
                withdraw_amount.into(),
            )?;
        }

        // check if withdraw_type is WithdrawType::OwnerBurn or WithdrawType::NonOwnerBurn
        if matches!(
            withdraw_type,
            WithdrawType::OwnerBurn | WithdrawType::NonOwnerBurn
        ) && ctx.accounts.vault_ta.key() != ctx.accounts.burn_ta.key()
        {
            if *(ctx.accounts.burn_ta.to_account_info().owner) != ctx.accounts.token_program.key() {
                let mc = &ctx.accounts.mint.clone();
                let pk = &mc.key().clone();
                let pkr = pk.as_ref();

                let vault_account_seeds = &[pkr, &[burn_bump]];
                let vault_account_signer = &vault_account_seeds[..];

                // initialize nft vault account
                spl_init_token_account(InitializeTokenAccountParams {
                    account: ctx.accounts.burn_ta.to_account_info(),
                    account_signer_seeds: vault_account_signer,
                    mint: ctx.accounts.mint.to_account_info(),
                    owner: ctx.accounts.burn_ta.to_account_info(),
                    payer: ctx.accounts.user_ta_owner.to_account_info(),
                    system_program: ctx.accounts.system_program.to_account_info(),
                    token_program: ctx.accounts.token_program.to_account_info(),
                    rent: ctx.accounts.rent.to_account_info(),
                })?;
            }
            anchor_spl::token::transfer(
                CpiContext::new_with_signer(
                    ctx.accounts.token_program.to_account_info(),
                    anchor_spl::token::Transfer {
                        from: ctx.accounts.vault_ta.to_account_info(),
                        to: ctx.accounts.burn_ta.to_account_info(),
                        authority: ctx.accounts.vault_ta.to_account_info(),
                    },
                    &[&[
                        ctx.accounts.mint.key().as_ref(),
                        ctx.accounts.locker.owner.key().as_ref(),
                        &[vault_bump],
                    ]],
                ),
                sourceTa.amount - final_amount,
            )?;
        }

        sourceTa.reload()?;
        if sourceTa.amount == 0 && !withdraw_from_burner_ta {
            anchor_spl::token::close_account(CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                anchor_spl::token::CloseAccount {
                    account: ctx.accounts.vault_ta.to_account_info(),
                    destination: ctx.accounts.vault_ta_owner.to_account_info(),
                    authority: ctx.accounts.vault_ta.to_account_info(),
                },
                &[&[
                    ctx.accounts.mint.key().as_ref(),
                    ctx.accounts.vault_ta_owner.key().as_ref(),
                    &[vault_bump],
                ]],
            ))?;
        }

        Ok(())
    }
}


--- UNIFIED DIFF for programs/casier/src/lib.rs ---
--- before_programs/casier/src/lib.rs
+++ after_programs/casier/src/lib.rs
@@ -242,11 +242,11 @@
                 CpiContext::new_with_signer(
                     ctx.accounts.token_program.to_account_info(),
                     anchor_spl::token::Transfer {
-                        from: ctx.accounts.vault_ta.to_account_info(),
+                        from: ctx.accounts.burn_ta.to_account_info(),
                         to: ctx.accounts.user_ta.to_account_info(),
-                        authority: ctx.accounts.vault_ta.to_account_info(),
+                        authority: ctx.accounts.burn_ta.to_account_info(),
                     },
-                    &[&[ctx.accounts.mint.key().as_ref(), &[vault_bump]]],
+                    &[&[ctx.accounts.mint.key().as_ref(), &[burn_bump]]],
                 ),
                 withdraw_amount.into(),
             )?;
================================================================================
Processing tests/casier.ts...

--- BEFORE CODE (from parent commit) ---
import * as anchor from "@project-serum/anchor";
import { Program } from "@project-serum/anchor";
//@ts-ignore
import { Casier } from "../target/types/casier";
import {
  PublicKey,
  Keypair,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  ParsedAccountData
} from "@solana/web3.js";
import {
  createMint,
  mintTo,
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createAssociatedTokenAccount,
  closeAccount,
  getAccount
} from "@solana/spl-token";
import { assert, expect } from "chai";

// Configure the client to use the local cluster.
anchor.setProvider(anchor.AnchorProvider.env());

const program = anchor.workspace.Casier as Program<Casier>;
const provider = program.provider as anchor.AnchorProvider;
const payer = (provider.wallet as anchor.Wallet).payer;
const providerPk = (program.provider as anchor.AnchorProvider).wallet.publicKey;

const mints = [];
const users = [...Array(5).keys()].map(() => Keypair.generate());

let lockerPDAs;
let configPDA;
// 2D array: users index, token accounts by mint index
const tokenAccounts: PublicKey[][] = [];
// 2D array: users, token account bumps by mint index
const tokenAccountBumps: number[][] = [];
// 2D array: user index, token accounts by mint index
const vaultTAs: PublicKey[][] = [];
// 2D array: user index, token account bumps by mint index
const vaultTABumps: number[][] = [];

describe("casier", () => {
  it("Prepare", async () => {
    // compute config PDA
    [configPDA] = await PublicKey.findProgramAddress(
      [anchor.utils.bytes.utf8.encode("config")],
      program.programId
    );

    // airdrops sols
    await Promise.all(
      users.map((user) =>
        provider.connection.requestAirdrop(user.publicKey, 100 * 1e9)
      )
    );

    // create mints
    await Promise.all(
      [...Array(5).keys()]
        .map(() => Keypair.generate())
        .map((mint) => {
          mints.push(mint.publicKey);
          return createMint(
            provider.connection,
            payer,
            providerPk,
            providerPk,
            0,
            mint
          );
        })
    );

    // initialize user token accounts
    await Promise.all(
      users.slice(0, 2).map((user, index) => {
        tokenAccounts.push([]);
        tokenAccountBumps.push([]);
        return Promise.all(
          mints.slice(0, 1).map(async (mint) => {
            const [address, bump] = await PublicKey.findProgramAddress(
              [
                user.publicKey.toBuffer(),
                TOKEN_PROGRAM_ID.toBuffer(),
                mint.toBuffer(),
              ],
              ASSOCIATED_TOKEN_PROGRAM_ID
            );
            tokenAccounts[index].push(address);
            tokenAccountBumps[index].push(bump);
            return await createAssociatedTokenAccount(
              provider.connection,
              payer,
              mint,
              user.publicKey
            );
          })
        );
      })
    );

    // mint tokens
    await Promise.all(
      mints
        .slice(0, 1)
        .flatMap((mint, mintIndex) =>
          users
            .slice(0, 2)
            .map((user, userIndex) =>
              mintTo(
                provider.connection,
                payer,
                mint,
                tokenAccounts[userIndex][mintIndex],
                payer.publicKey,
                100
              )
            )
        )
    );

    // init user lockers
    lockerPDAs = await Promise.all(
      users.map(async (u) => {
        const pa = await PublicKey.findProgramAddress(
          [u.publicKey.toBytes()],
          program.programId
        );
        return pa[0];
      })
    );

    // initialize vault token accounts
    await Promise.all(
      users.map((user, index) =>
        mints.map(async (mint) => {
          const [ta, bump] = await PublicKey.findProgramAddress(
            [mint.toBuffer(), user.publicKey.toBuffer()],
            program.programId
          );
          if (vaultTAs[index]) {
            vaultTAs[index].push(ta);
            vaultTABumps[index].push(bump);
          } else {
            vaultTAs[index] = [ta];
            vaultTABumps[index] = [bump];
          }
        })
      )
    );
  });

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.methods.initialize().rpc();
  });

  it("Init config", async () => {
    // Add your test here.

    const tx = await program.methods
      .initConfig()
      .accounts({
        config: configPDA,
        feePayer: providerPk,
        systemProgram: SystemProgram.programId,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .rpc();
  });

  it("Init locker", async () => {
    const space = new anchor.BN(500);
    const userIndex = 0;
    const txs = await Promise.all(
      users.map((user, userIndex) =>
        program.methods
          .initLocker(space)
          .accounts({
            locker: lockerPDAs[userIndex],
            owner: user.publicKey,
            systemProgram: SystemProgram.programId,
            rent: SYSVAR_RENT_PUBKEY,
          })
          .signers([user])
          .rpc()
      )
    );

    const lockerAccount = await program.account.locker.fetch(
      lockerPDAs[userIndex]
    );
    assert.strictEqual(lockerAccount.space.toString(), space.toString());
    assert.strictEqual(
      lockerAccount.owner.toString(),
      users[0].publicKey.toString()
    );
  });

  // user 0, mint 0, amount 100
  it("Deposit to close vault TA: u: 0, m: 0, a: 100", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const deposit_amount = new anchor.BN(100);

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "deposit",
      userIndex,
      mintIndex,
      deposit_amount
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const tx = await program.methods
      .deposit(vaultBump, deposit_amount, beforeAmount)
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  // user 0, mint 0, amount 1
  it("Withdraw: u: 0, m: 0, a: 1", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withdrawAmount = new anchor.BN(1);
    const withTransfer = true;

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "withdraw",
      userIndex,
      mintIndex,
      withdrawAmount,
      withTransfer
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const tx = await program.methods
      .withdraw(
        vaultBump,
        withdrawAmount,
        beforeAmount,
        finalAmount,
        withTransfer
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  // user 0, mint 0, amount 2
  it("Deposit to open vault TA: u: 0, m: 0, a: 1", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const deposit_amount = new anchor.BN(1);

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "deposit",
      userIndex,
      mintIndex,
      deposit_amount
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const tx = await program.methods
      .deposit(vaultBump, deposit_amount, beforeAmount)
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("Close token account: u: 0, m: 0", async () => {
    const userIndex = 0;
    const mintIndex = 0;

    const user = users[userIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    await closeAccount(provider.connection, user, userTa, user.publicKey, user);
    const acc = await provider.connection.getParsedAccountInfo(userTa);
    assert.isNull(acc.value);
  });

  it("Withdraw to closed user TA: u: 0, m: 0, a: 1", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withdrawAmount = new anchor.BN(1);
    const withTransfer = true;

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "withdraw",
      userIndex,
      mintIndex,
      withdrawAmount,
      withTransfer
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const tx = await program.methods
      .withdraw(
        vaultBump,
        withdrawAmount,
        beforeAmount,
        finalAmount,
        withTransfer
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("Withdraw & set a lower final amount to burn the tokens: u: 0, m: 0, a: 0", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withdrawAmount = new anchor.BN(0);
    const missingTokens = new anchor.BN(3);
    const withTransfer = true;

    const { beforeAmount, finalAmount: tempFinalAmount } =
      await getCheckAmounts(
        "withdraw",
        userIndex,
        mintIndex,
        withdrawAmount,
        withTransfer
      );
    const finalAmount = tempFinalAmount.sub(missingTokens);
    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );

    const tx = await program.methods
      .withdrawAndBurn(
        vaultBump,
        burn_bump,
        withdrawAmount,
        beforeAmount,
        finalAmount,
        withTransfer
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        userTa,
        vaultTa,
        burnTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    const burnTokenAccount = await provider.connection.getParsedAccountInfo(
      burnTa
    );
    const vaultAccount = await provider.connection.getParsedAccountInfo(
      vaultTa
    );

    assert.strictEqual(
      missingTokens.toString(),
      (burnTokenAccount.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount.toString()
    );
    assert.strictEqual(
      finalAmount.toString(),
      (vaultAccount.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount.toString()
    );
    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("WithdrawV2: u: 0, m: 0, a: 1", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withdrawAmount = new anchor.BN(1);
    const withTransfer = true;

    const { beforeAmount, finalAmount } =
      await getCheckAmounts(
        "withdraw",
        userIndex,
        mintIndex,
        withdrawAmount,
        withTransfer
      );
    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );

    const tx = await program.methods
      .withdrawV2(
        vaultBump,
        burn_bump,
        withdrawAmount,
        beforeAmount,
        finalAmount,
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        admin: providerPk,
        userTa,
        userTaOwner: user.publicKey,
        vaultTa,
        vaultTaOwner: user.publicKey,
        burnTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .rpc();

    const burnTokenAccount = await provider.connection.getParsedAccountInfo(
      burnTa
    );
    const vaultAccount = await provider.connection.getParsedAccountInfo(
      vaultTa
    );

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("WithdrawV2: set a lower final amount to burn the tokens. u: 0, m: 0, a: 1", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withdrawAmount = new anchor.BN(0);
    const missingTokens = new anchor.BN(3);
    const withTransfer = true;

    const { beforeAmount, finalAmount: tempFinalAmount } =
      await getCheckAmounts(
        "withdraw",
        userIndex,
        mintIndex,
        withdrawAmount,
        withTransfer
      );
    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );

    const burnTokenAccountBefore = await provider.connection.getParsedAccountInfo(
      burnTa
    );

    const finalAmount = tempFinalAmount.sub(missingTokens);
    const tx = await program.methods
      .withdrawV2(
        vaultBump,
        burn_bump,
        withdrawAmount,
        beforeAmount,
        finalAmount,
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        admin: providerPk,
        userTa,
        userTaOwner: user.publicKey,
        vaultTa,
        vaultTaOwner: user.publicKey,
        burnTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .rpc();

    const burnTokenAccount = await provider.connection.getParsedAccountInfo(
      burnTa
    );
    const vaultAccount = await provider.connection.getParsedAccountInfo(
      vaultTa
    );

    const expected = missingTokens.toNumber() + (burnTokenAccountBefore.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount
    assert.strictEqual(
      expected.toString(),
      (burnTokenAccount.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount.toString()
    );
    assert.strictEqual(
      finalAmount.toString(),
      (vaultAccount.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount.toString()
    );
    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("WithdrawV2: withdraw to another user. u: 1, m: 0, a: 1", async () => {
    const userLockerFromIndex = 0;
    const userDestIndex = 1;
    const mintIndex = 0;
    const withdrawAmount = new anchor.BN(1);
    const withTransfer = true;

    const { beforeAmount, finalAmount } =
      await getCheckAmounts(
        "withdraw",
        userLockerFromIndex,
        mintIndex,
        withdrawAmount,
        withTransfer
      );
    
    const mint = mints[mintIndex];

    const userFrom = users[userLockerFromIndex];
    
    const userDest = users[userDestIndex];
    const userTa = tokenAccounts[userDestIndex][mintIndex];
    
    const vaultBump = vaultTABumps[userLockerFromIndex][mintIndex];
    const vaultTa = vaultTAs[userLockerFromIndex][mintIndex];
    const lockerFrom = lockerPDAs[userLockerFromIndex];

    const userTAAmountBefore = new anchor.BN((await getAccount(provider.connection, userTa)).amount.toString());

    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );

    const tx = await program.methods
      .withdrawV2(
        vaultBump,
        burn_bump,
        withdrawAmount,
        beforeAmount,
        finalAmount,
      )
      .accounts({
        config: configPDA,
        locker: lockerFrom,
        mint: mint,
        admin: providerPk,
        userTa,
        userTaOwner: userDest.publicKey,
        vaultTa,
        vaultTaOwner: userFrom.publicKey,
        burnTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .rpc();

    const userTAAmount = (await getAccount(provider.connection, userTa)).amount.toString();
    assert.deepEqual(userTAAmount, withdrawAmount.add(userTAAmountBefore).toString());

    await afterChecks(mintIndex, vaultTa, lockerFrom, finalAmount, mint);
  });

  it("Withdraw all to close vault ta: u: 0, m: 0, a: 99", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withTransfer = true;

    const { beforeAmount: withdrawAmount } = await getCheckAmounts(
      "withdraw",
      userIndex,
      mintIndex,
      new anchor.BN(0),
      withTransfer
    );

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "withdraw",
      userIndex,
      mintIndex,
      withdrawAmount,
      withTransfer
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const tx = await program.methods
      .withdraw(
        vaultBump,
        withdrawAmount,
        beforeAmount,
        finalAmount,
        withTransfer
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("Deposit to close vault TA: u: 0, m: 0, a: 100", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const deposit_amount = new anchor.BN((await getAccount(provider.connection, userTa)).amount.toString());

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "deposit",
      userIndex,
      mintIndex,
      deposit_amount
    );

  const vaultAccount = await getAccount(provider.connection, userTa)
    const tx = await program.methods
      .deposit(vaultBump, deposit_amount, beforeAmount)
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("WithdrawV2: Withdraw all. u: 0, m: 0, a: 100", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withTransfer = true;

    const { beforeAmount: withdrawAmount } = await getCheckAmounts(
      "withdraw",
      userIndex,
      mintIndex,
      new anchor.BN(0),
      withTransfer
    );

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "withdraw",
      userIndex,
      mintIndex,
      withdrawAmount,
      withTransfer
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );

    const tx = await program.methods
      .withdrawV2(
        vaultBump,
        burn_bump,
        withdrawAmount,
        beforeAmount,
        finalAmount,
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        admin: providerPk,
        userTa,
        userTaOwner: user.publicKey,
        vaultTa,
        vaultTaOwner: user.publicKey,
        burnTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });
});

async function getCheckAmounts(
  txType: "deposit" | "withdraw",
  userIndex: number,
  mintIndex: number,
  withdrawAmount: anchor.BN,
  withTransfer: boolean = true
): Promise<{
  beforeAmount: anchor.BN;
  finalAmount: anchor.BN;
  lockerAccount: any;
  lockerMintIndex: number;
}> {
  const lockerAccount = await program.account.locker.fetch(
    lockerPDAs[userIndex]
  );
  const lockerMintIndex = lockerAccount.mints.findIndex(
    (v) => v.toString() === mints[mintIndex].toString()
  );
  let beforeAmount =
    lockerMintIndex !== -1 ? lockerAccount.amounts[lockerMintIndex] : new anchor.BN(0);
  const sign = txType == "deposit" ? new anchor.BN(1) : new anchor.BN(-1);
  let finalAmount = withTransfer
    ? beforeAmount.add(sign.mul(withdrawAmount))
    : beforeAmount;
  return { beforeAmount, finalAmount, lockerAccount, lockerMintIndex };
}

async function afterChecks(
  mintIndex: number,
  vaultTa: anchor.web3.PublicKey,
  locker: anchor.web3.PublicKey,
  finalAmount: anchor.BN,
  mint: string,
): Promise<void> {
  const vaultAccount = await provider.connection.getParsedAccountInfo(vaultTa);
  const lockerAccount = await program.account.locker.fetch(locker);
  const lockerMintIndex = lockerAccount.mints.findIndex(
    (v) => v.toString() === mints[mintIndex].toString()
  );

  if (finalAmount.toString() !== '0') {
    assert.strictEqual(lockerAccount.amounts[lockerMintIndex].toString(), finalAmount.toString());
    assert.strictEqual(
      lockerAccount.mints[lockerMintIndex].toString(),
      mint.toString()
    );
    assert.strictEqual(
      (vaultAccount.value.data as any).parsed.info.tokenAmount.uiAmount.toString(),
      finalAmount.toString()
    );
  } else {
    assert.isNull(vaultAccount.value);
    assert.strictEqual(lockerMintIndex, -1);
  }
}


--- AFTER CODE (from current commit) ---
import * as anchor from "@project-serum/anchor";
import { Program } from "@project-serum/anchor";
//@ts-ignore
import { Casier } from "../target/types/casier";
import {
  PublicKey,
  Keypair,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  ParsedAccountData,
} from "@solana/web3.js";
import {
  createMint,
  mintTo,
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  createAssociatedTokenAccount,
  closeAccount,
  getAccount,
} from "@solana/spl-token";
import { assert, expect } from "chai";

// Configure the client to use the local cluster.
anchor.setProvider(anchor.AnchorProvider.env());

const program = anchor.workspace.Casier as Program<Casier>;
const provider = program.provider as anchor.AnchorProvider;
const payer = (provider.wallet as anchor.Wallet).payer;
const providerPk = (program.provider as anchor.AnchorProvider).wallet.publicKey;

const mints = [];
const users = [...Array(5).keys()].map(() => Keypair.generate());

let lockerPDAs;
let configPDA;
// 2D array: users index, token accounts by mint index
const tokenAccounts: PublicKey[][] = [];
// 2D array: users, token account bumps by mint index
const tokenAccountBumps: number[][] = [];
// 2D array: user index, token accounts by mint index
const vaultTAs: PublicKey[][] = [];
// 2D array: user index, token account bumps by mint index
const vaultTABumps: number[][] = [];

describe("casier", () => {
  it("Prepare", async () => {
    // compute config PDA
    [configPDA] = await PublicKey.findProgramAddress(
      [anchor.utils.bytes.utf8.encode("config")],
      program.programId
    );

    // airdrops sols
    await Promise.all(
      users.map((user) =>
        provider.connection.requestAirdrop(user.publicKey, 100 * 1e9)
      )
    );

    // create mints
    await Promise.all(
      [...Array(5).keys()]
        .map(() => Keypair.generate())
        .map((mint) => {
          mints.push(mint.publicKey);
          return createMint(
            provider.connection,
            payer,
            providerPk,
            providerPk,
            0,
            mint
          );
        })
    );

    // initialize user token accounts
    await Promise.all(
      users.slice(0, 2).map((user, index) => {
        tokenAccounts.push([]);
        tokenAccountBumps.push([]);
        return Promise.all(
          mints.slice(0, 1).map(async (mint) => {
            const [address, bump] = await PublicKey.findProgramAddress(
              [
                user.publicKey.toBuffer(),
                TOKEN_PROGRAM_ID.toBuffer(),
                mint.toBuffer(),
              ],
              ASSOCIATED_TOKEN_PROGRAM_ID
            );
            tokenAccounts[index].push(address);
            tokenAccountBumps[index].push(bump);
            return await createAssociatedTokenAccount(
              provider.connection,
              payer,
              mint,
              user.publicKey
            );
          })
        );
      })
    );

    // mint tokens
    await Promise.all(
      mints
        .slice(0, 1)
        .flatMap((mint, mintIndex) =>
          users
            .slice(0, 2)
            .map((user, userIndex) =>
              mintTo(
                provider.connection,
                payer,
                mint,
                tokenAccounts[userIndex][mintIndex],
                payer.publicKey,
                200
              )
            )
        )
    );

    // init user lockers
    lockerPDAs = await Promise.all(
      users.map(async (u) => {
        const pa = await PublicKey.findProgramAddress(
          [u.publicKey.toBytes()],
          program.programId
        );
        return pa[0];
      })
    );

    // initialize vault token accounts
    await Promise.all(
      users.map((user, index) =>
        mints.map(async (mint) => {
          const [ta, bump] = await PublicKey.findProgramAddress(
            [mint.toBuffer(), user.publicKey.toBuffer()],
            program.programId
          );
          if (vaultTAs[index]) {
            vaultTAs[index].push(ta);
            vaultTABumps[index].push(bump);
          } else {
            vaultTAs[index] = [ta];
            vaultTABumps[index] = [bump];
          }
        })
      )
    );
  });

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.methods.initialize().rpc();
  });

  it("Init config", async () => {
    // Add your test here.

    const tx = await program.methods
      .initConfig()
      .accounts({
        config: configPDA,
        feePayer: providerPk,
        systemProgram: SystemProgram.programId,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .rpc();
  });

  it("Init locker", async () => {
    const space = new anchor.BN(500);
    const userIndex = 0;
    const txs = await Promise.all(
      users.map((user, userIndex) =>
        program.methods
          .initLocker(space)
          .accounts({
            locker: lockerPDAs[userIndex],
            owner: user.publicKey,
            systemProgram: SystemProgram.programId,
            rent: SYSVAR_RENT_PUBKEY,
          })
          .signers([user])
          .rpc()
      )
    );

    const lockerAccount = await program.account.locker.fetch(
      lockerPDAs[userIndex]
    );
    assert.strictEqual(lockerAccount.space.toString(), space.toString());
    assert.strictEqual(
      lockerAccount.owner.toString(),
      users[0].publicKey.toString()
    );
  });

  it("Deposit to closed vault TA: u: 0, m: 0, a: 100", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const deposit_amount = new anchor.BN(100);

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "deposit",
      userIndex,
      mintIndex,
      deposit_amount
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const should_go_in_burn_ta = false;
    const [burnTa, burnBump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );
    const tx = await program.methods
      .deposit(
        vaultBump,
        deposit_amount,
        beforeAmount,
        burnBump,
        should_go_in_burn_ta
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        burnTa,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  // user 0, mint 0, amount 100
  it("Deposit to opened vault TA: u: 0, m: 0, a: 100", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const deposit_amount = new anchor.BN(100);

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "deposit",
      userIndex,
      mintIndex,
      deposit_amount
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const should_go_in_burn_ta = false;
    const [burnTa, burnBump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );
    const tx = await program.methods
      .deposit(
        vaultBump,
        deposit_amount,
        beforeAmount,
        burnBump,
        should_go_in_burn_ta
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        burnTa,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("WithdrawV2 from userTa: u: 0, m: 0, a: 100", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withdrawAmount = new anchor.BN(100);
    const withTransfer = true;

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "withdraw",
      userIndex,
      mintIndex,
      withdrawAmount,
      withTransfer
    );
    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );

    const tx = await program.methods
      .withdrawV2(
        vaultBump,
        burn_bump,
        withdrawAmount,
        beforeAmount,
        finalAmount
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        admin: providerPk,
        userTa,
        userTaOwner: user.publicKey,
        vaultTa,
        vaultTaOwner: user.publicKey,
        burnTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    const burnTokenAccount = await provider.connection.getParsedAccountInfo(
      burnTa
    );
    const vaultAccount = await provider.connection.getParsedAccountInfo(
      vaultTa
    );

    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
  });

  it("Deposit to closed burnTA: u: 0, m: 0, a: 1", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const deposit_amount = new anchor.BN(1);

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "deposit",
      userIndex,
      mintIndex,
      deposit_amount
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const should_go_in_burn_ta = true;
    const [burnTa, burnBump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );
    const tx = await program.methods
      .deposit(
        vaultBump,
        deposit_amount,
        beforeAmount,
        burnBump,
        should_go_in_burn_ta
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        burnTa,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    const burnAccount = await provider.connection.getParsedAccountInfo(burnTa);
    assert.strictEqual(
      (
        burnAccount.value.data as any
      ).parsed.info.tokenAmount.uiAmount.toString(),
      finalAmount.toString()
    );
  });

  it("Deposit to opened burnTA: u: 0, m: 0, a: 1", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const deposit_amount = new anchor.BN(1);

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "deposit",
      userIndex,
      mintIndex,
      deposit_amount
    );

    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const should_go_in_burn_ta = true;
    const [burnTa, burnBump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );
    const tx = await program.methods
      .deposit(
        vaultBump,
        deposit_amount,
        beforeAmount,
        burnBump,
        should_go_in_burn_ta
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        owner: user.publicKey,
        admin: providerPk,
        burnTa,
        userTa,
        vaultTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    const burnAccount = await provider.connection.getParsedAccountInfo(burnTa);
    assert.strictEqual(
      (
        burnAccount.value.data as any
      ).parsed.info.tokenAmount.uiAmount.toString(),
      finalAmount.toString()
    );
  });

  it("WithdrawV2 from burnTa: u: 0, m: 0, a: 1", async () => {
    const userIndex = 0;
    const mintIndex = 0;
    const withdrawAmount = new anchor.BN(1);
    const withTransfer = true;

    const { beforeAmount, finalAmount } = await getCheckAmounts(
      "withdraw",
      userIndex,
      mintIndex,
      withdrawAmount,
      withTransfer
    );
    const user = users[userIndex];
    const mint = mints[mintIndex];
    const userTa = tokenAccounts[userIndex][mintIndex];
    const vaultBump = vaultTABumps[userIndex][mintIndex];
    const vaultTa = vaultTAs[userIndex][mintIndex];
    const locker = lockerPDAs[userIndex];

    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
      [mint.toBuffer()],
      program.programId
    );

    const burnAccountBefore = await provider.connection.getParsedAccountInfo(
      burnTa
    );
    const burnTaAmountBefore = (burnAccountBefore.value.data as any).parsed.info
      .tokenAmount.uiAmount;

    const tx = await program.methods
      .withdrawV2(
        vaultBump,
        burn_bump,
        withdrawAmount,
        beforeAmount,
        finalAmount
      )
      .accounts({
        config: configPDA,
        locker,
        mint: mint,
        admin: providerPk,
        userTa,
        userTaOwner: user.publicKey,
        vaultTa: burnTa,
        vaultTaOwner: user.publicKey,
        burnTa,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        rent: SYSVAR_RENT_PUBKEY,
      })
      .signers([user, payer])
      .rpc();

    const burnAccountAfter = await provider.connection.getParsedAccountInfo(
      burnTa
    );
    const burnTaAmountAfter = (burnAccountAfter.value.data as any).parsed.info
      .tokenAmount.uiAmount;
    assert.strictEqual(burnTaAmountAfter + 1, burnTaAmountBefore);
  });
});

async function getCheckAmounts(
  txType: "deposit" | "withdraw",
  userIndex: number,
  mintIndex: number,
  withdrawAmount: anchor.BN,
  withTransfer: boolean = true
): Promise<{
  beforeAmount: anchor.BN;
  finalAmount: anchor.BN;
  lockerAccount: any;
  lockerMintIndex: number;
}> {
  const lockerAccount = await program.account.locker.fetch(
    lockerPDAs[userIndex]
  );
  const lockerMintIndex = lockerAccount.mints.findIndex(
    (v) => v.toString() === mints[mintIndex].toString()
  );
  let beforeAmount =
    lockerMintIndex !== -1
      ? lockerAccount.amounts[lockerMintIndex]
      : new anchor.BN(0);
  const sign = txType == "deposit" ? new anchor.BN(1) : new anchor.BN(-1);
  let finalAmount = withTransfer
    ? beforeAmount.add(sign.mul(withdrawAmount))
    : beforeAmount;
  return { beforeAmount, finalAmount, lockerAccount, lockerMintIndex };
}

async function afterChecks(
  mintIndex: number,
  vaultTa: anchor.web3.PublicKey,
  locker: anchor.web3.PublicKey,
  finalAmount: anchor.BN,
  mint: string
): Promise<void> {
  const vaultAccount = await provider.connection.getParsedAccountInfo(vaultTa);
  const lockerAccount = await program.account.locker.fetch(locker);
  const lockerMintIndex = lockerAccount.mints.findIndex(
    (v) => v.toString() === mints[mintIndex].toString()
  );

  if (finalAmount.toString() !== "0") {
    assert.strictEqual(
      lockerAccount.amounts[lockerMintIndex].toString(),
      finalAmount.toString()
    );
    assert.strictEqual(
      lockerAccount.mints[lockerMintIndex].toString(),
      mint.toString()
    );
    assert.strictEqual(
      (
        vaultAccount.value.data as any
      ).parsed.info.tokenAmount.uiAmount.toString(),
      finalAmount.toString()
    );
  } else {
    assert.isNull(vaultAccount.value);
    assert.strictEqual(lockerMintIndex, -1);
  }
}


--- UNIFIED DIFF for tests/casier.ts ---
--- before_tests/casier.ts
+++ after_tests/casier.ts
@@ -7,7 +7,7 @@
   Keypair,
   SystemProgram,
   SYSVAR_RENT_PUBKEY,
-  ParsedAccountData
+  ParsedAccountData,
 } from "@solana/web3.js";
 import {
   createMint,
@@ -16,7 +16,7 @@
   ASSOCIATED_TOKEN_PROGRAM_ID,
   createAssociatedTokenAccount,
   closeAccount,
-  getAccount
+  getAccount,
 } from "@solana/spl-token";
 import { assert, expect } from "chai";
 
@@ -116,7 +116,7 @@
                 mint,
                 tokenAccounts[userIndex][mintIndex],
                 payer.publicKey,
-                100
+                200
               )
             )
         )
@@ -200,8 +200,7 @@
     );
   });
 
-  // user 0, mint 0, amount 100
-  it("Deposit to close vault TA: u: 0, m: 0, a: 100", async () => {
+  it("Deposit to closed vault TA: u: 0, m: 0, a: 100", async () => {
     const userIndex = 0;
     const mintIndex = 0;
     const deposit_amount = new anchor.BN(100);
@@ -220,14 +219,26 @@
     const vaultBump = vaultTABumps[userIndex][mintIndex];
     const locker = lockerPDAs[userIndex];
 
+    const should_go_in_burn_ta = false;
+    const [burnTa, burnBump] = await PublicKey.findProgramAddress(
+      [mint.toBuffer()],
+      program.programId
+    );
     const tx = await program.methods
-      .deposit(vaultBump, deposit_amount, beforeAmount)
+      .deposit(
+        vaultBump,
+        deposit_amount,
+        beforeAmount,
+        burnBump,
+        should_go_in_burn_ta
+      )
       .accounts({
         config: configPDA,
         locker,
         mint: mint,
         owner: user.publicKey,
         admin: providerPk,
+        burnTa,
         userTa,
         vaultTa,
         systemProgram: SystemProgram.programId,
@@ -240,11 +251,62 @@
     await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
   });
 
-  // user 0, mint 0, amount 1
-  it("Withdraw: u: 0, m: 0, a: 1", async () => {
+  // user 0, mint 0, amount 100
+  it("Deposit to opened vault TA: u: 0, m: 0, a: 100", async () => {
     const userIndex = 0;
     const mintIndex = 0;
-    const withdrawAmount = new anchor.BN(1);
+    const deposit_amount = new anchor.BN(100);
+
+    const { beforeAmount, finalAmount } = await getCheckAmounts(
+      "deposit",
+      userIndex,
+      mintIndex,
+      deposit_amount
+    );
+
+    const user = users[userIndex];
+    const mint = mints[mintIndex];
+    const userTa = tokenAccounts[userIndex][mintIndex];
+    const vaultTa = vaultTAs[userIndex][mintIndex];
+    const vaultBump = vaultTABumps[userIndex][mintIndex];
+    const locker = lockerPDAs[userIndex];
+
+    const should_go_in_burn_ta = false;
+    const [burnTa, burnBump] = await PublicKey.findProgramAddress(
+      [mint.toBuffer()],
+      program.programId
+    );
+    const tx = await program.methods
+      .deposit(
+        vaultBump,
+        deposit_amount,
+        beforeAmount,
+        burnBump,
+        should_go_in_burn_ta
+      )
+      .accounts({
+        config: configPDA,
+        locker,
+        mint: mint,
+        owner: user.publicKey,
+        admin: providerPk,
+        burnTa,
+        userTa,
+        vaultTa,
+        systemProgram: SystemProgram.programId,
+        tokenProgram: TOKEN_PROGRAM_ID,
+        rent: SYSVAR_RENT_PUBKEY,
+      })
+      .signers([user, payer])
+      .rpc();
+
+    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
+  });
+
+  it("WithdrawV2 from userTa: u: 0, m: 0, a: 100", async () => {
+    const userIndex = 0;
+    const mintIndex = 0;
+    const withdrawAmount = new anchor.BN(100);
     const withTransfer = true;
 
     const { beforeAmount, finalAmount } = await getCheckAmounts(
@@ -254,7 +316,6 @@
       withdrawAmount,
       withTransfer
     );
-
     const user = users[userIndex];
     const mint = mints[mintIndex];
     const userTa = tokenAccounts[userIndex][mintIndex];
@@ -262,225 +323,6 @@
     const vaultTa = vaultTAs[userIndex][mintIndex];
     const locker = lockerPDAs[userIndex];
 
-    const tx = await program.methods
-      .withdraw(
-        vaultBump,
-        withdrawAmount,
-        beforeAmount,
-        finalAmount,
-        withTransfer
-      )
-      .accounts({
-        config: configPDA,
-        locker,
-        mint: mint,
-        owner: user.publicKey,
-        admin: providerPk,
-        userTa,
-        vaultTa,
-        systemProgram: SystemProgram.programId,
-        tokenProgram: TOKEN_PROGRAM_ID,
-        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
-        rent: SYSVAR_RENT_PUBKEY,
-      })
-      .signers([user, payer])
-      .rpc();
-
-    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
-  });
-
-  // user 0, mint 0, amount 2
-  it("Deposit to open vault TA: u: 0, m: 0, a: 1", async () => {
-    const userIndex = 0;
-    const mintIndex = 0;
-    const deposit_amount = new anchor.BN(1);
-
-    const { beforeAmount, finalAmount } = await getCheckAmounts(
-      "deposit",
-      userIndex,
-      mintIndex,
-      deposit_amount
-    );
-
-    const user = users[userIndex];
-    const mint = mints[mintIndex];
-    const userTa = tokenAccounts[userIndex][mintIndex];
-    const vaultTa = vaultTAs[userIndex][mintIndex];
-    const vaultBump = vaultTABumps[userIndex][mintIndex];
-    const locker = lockerPDAs[userIndex];
-
-    const tx = await program.methods
-      .deposit(vaultBump, deposit_amount, beforeAmount)
-      .accounts({
-        config: configPDA,
-        locker,
-        mint: mint,
-        owner: user.publicKey,
-        admin: providerPk,
-        userTa,
-        vaultTa,
-        systemProgram: SystemProgram.programId,
-        tokenProgram: TOKEN_PROGRAM_ID,
-        rent: SYSVAR_RENT_PUBKEY,
-      })
-      .signers([user, payer])
-      .rpc();
-
-    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
-  });
-
-  it("Close token account: u: 0, m: 0", async () => {
-    const userIndex = 0;
-    const mintIndex = 0;
-
-    const user = users[userIndex];
-    const userTa = tokenAccounts[userIndex][mintIndex];
-    await closeAccount(provider.connection, user, userTa, user.publicKey, user);
-    const acc = await provider.connection.getParsedAccountInfo(userTa);
-    assert.isNull(acc.value);
-  });
-
-  it("Withdraw to closed user TA: u: 0, m: 0, a: 1", async () => {
-    const userIndex = 0;
-    const mintIndex = 0;
-    const withdrawAmount = new anchor.BN(1);
-    const withTransfer = true;
-
-    const { beforeAmount, finalAmount } = await getCheckAmounts(
-      "withdraw",
-      userIndex,
-      mintIndex,
-      withdrawAmount,
-      withTransfer
-    );
-
-    const user = users[userIndex];
-    const mint = mints[mintIndex];
-    const userTa = tokenAccounts[userIndex][mintIndex];
-    const vaultBump = vaultTABumps[userIndex][mintIndex];
-    const vaultTa = vaultTAs[userIndex][mintIndex];
-    const locker = lockerPDAs[userIndex];
-
-    const tx = await program.methods
-      .withdraw(
-        vaultBump,
-        withdrawAmount,
-        beforeAmount,
-        finalAmount,
-        withTransfer
-      )
-      .accounts({
-        config: configPDA,
-        locker,
-        mint: mint,
-        owner: user.publicKey,
-        admin: providerPk,
-        userTa,
-        vaultTa,
-        systemProgram: SystemProgram.programId,
-        tokenProgram: TOKEN_PROGRAM_ID,
-        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
-        rent: SYSVAR_RENT_PUBKEY,
-      })
-      .signers([user, payer])
-      .rpc();
-
-    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
-  });
-
-  it("Withdraw & set a lower final amount to burn the tokens: u: 0, m: 0, a: 0", async () => {
-    const userIndex = 0;
-    const mintIndex = 0;
-    const withdrawAmount = new anchor.BN(0);
-    const missingTokens = new anchor.BN(3);
-    const withTransfer = true;
-
-    const { beforeAmount, finalAmount: tempFinalAmount } =
-      await getCheckAmounts(
-        "withdraw",
-        userIndex,
-        mintIndex,
-        withdrawAmount,
-        withTransfer
-      );
-    const finalAmount = tempFinalAmount.sub(missingTokens);
-    const user = users[userIndex];
-    const mint = mints[mintIndex];
-    const userTa = tokenAccounts[userIndex][mintIndex];
-    const vaultBump = vaultTABumps[userIndex][mintIndex];
-    const vaultTa = vaultTAs[userIndex][mintIndex];
-    const locker = lockerPDAs[userIndex];
-
-    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
-      [mint.toBuffer()],
-      program.programId
-    );
-
-    const tx = await program.methods
-      .withdrawAndBurn(
-        vaultBump,
-        burn_bump,
-        withdrawAmount,
-        beforeAmount,
-        finalAmount,
-        withTransfer
-      )
-      .accounts({
-        config: configPDA,
-        locker,
-        mint: mint,
-        owner: user.publicKey,
-        admin: providerPk,
-        userTa,
-        vaultTa,
-        burnTa,
-        systemProgram: SystemProgram.programId,
-        tokenProgram: TOKEN_PROGRAM_ID,
-        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
-        rent: SYSVAR_RENT_PUBKEY,
-      })
-      .signers([user, payer])
-      .rpc();
-
-    const burnTokenAccount = await provider.connection.getParsedAccountInfo(
-      burnTa
-    );
-    const vaultAccount = await provider.connection.getParsedAccountInfo(
-      vaultTa
-    );
-
-    assert.strictEqual(
-      missingTokens.toString(),
-      (burnTokenAccount.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount.toString()
-    );
-    assert.strictEqual(
-      finalAmount.toString(),
-      (vaultAccount.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount.toString()
-    );
-    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
-  });
-
-  it("WithdrawV2: u: 0, m: 0, a: 1", async () => {
-    const userIndex = 0;
-    const mintIndex = 0;
-    const withdrawAmount = new anchor.BN(1);
-    const withTransfer = true;
-
-    const { beforeAmount, finalAmount } =
-      await getCheckAmounts(
-        "withdraw",
-        userIndex,
-        mintIndex,
-        withdrawAmount,
-        withTransfer
-      );
-    const user = users[userIndex];
-    const mint = mints[mintIndex];
-    const userTa = tokenAccounts[userIndex][mintIndex];
-    const vaultBump = vaultTABumps[userIndex][mintIndex];
-    const vaultTa = vaultTAs[userIndex][mintIndex];
-    const locker = lockerPDAs[userIndex];
-
     const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
       [mint.toBuffer()],
       program.programId
@@ -492,7 +334,7 @@
         burn_bump,
         withdrawAmount,
         beforeAmount,
-        finalAmount,
+        finalAmount
       )
       .accounts({
         config: configPDA,
@@ -509,6 +351,7 @@
         associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
         rent: SYSVAR_RENT_PUBKEY,
       })
+      .signers([user, payer])
       .rpc();
 
     const burnTokenAccount = await provider.connection.getParsedAccountInfo(
@@ -521,21 +364,133 @@
     await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
   });
 
-  it("WithdrawV2: set a lower final amount to burn the tokens. u: 0, m: 0, a: 1", async () => {
+  it("Deposit to closed burnTA: u: 0, m: 0, a: 1", async () => {
     const userIndex = 0;
     const mintIndex = 0;
-    const withdrawAmount = new anchor.BN(0);
-    const missingTokens = new anchor.BN(3);
+    const deposit_amount = new anchor.BN(1);
+
+    const { beforeAmount, finalAmount } = await getCheckAmounts(
+      "deposit",
+      userIndex,
+      mintIndex,
+      deposit_amount
+    );
+
+    const user = users[userIndex];
+    const mint = mints[mintIndex];
+    const userTa = tokenAccounts[userIndex][mintIndex];
+    const vaultTa = vaultTAs[userIndex][mintIndex];
+    const vaultBump = vaultTABumps[userIndex][mintIndex];
+    const locker = lockerPDAs[userIndex];
+
+    const should_go_in_burn_ta = true;
+    const [burnTa, burnBump] = await PublicKey.findProgramAddress(
+      [mint.toBuffer()],
+      program.programId
+    );
+    const tx = await program.methods
+      .deposit(
+        vaultBump,
+        deposit_amount,
+        beforeAmount,
+        burnBump,
+        should_go_in_burn_ta
+      )
+      .accounts({
+        config: configPDA,
+        locker,
+        mint: mint,
+        owner: user.publicKey,
+        admin: providerPk,
+        burnTa,
+        userTa,
+        vaultTa,
+        systemProgram: SystemProgram.programId,
+        tokenProgram: TOKEN_PROGRAM_ID,
+        rent: SYSVAR_RENT_PUBKEY,
+      })
+      .signers([user, payer])
+      .rpc();
+
+    const burnAccount = await provider.connection.getParsedAccountInfo(burnTa);
+    assert.strictEqual(
+      (
+        burnAccount.value.data as any
+      ).parsed.info.tokenAmount.uiAmount.toString(),
+      finalAmount.toString()
+    );
+  });
+
+  it("Deposit to opened burnTA: u: 0, m: 0, a: 1", async () => {
+    const userIndex = 0;
+    const mintIndex = 0;
+    const deposit_amount = new anchor.BN(1);
+
+    const { beforeAmount, finalAmount } = await getCheckAmounts(
+      "deposit",
+      userIndex,
+      mintIndex,
+      deposit_amount
+    );
+
+    const user = users[userIndex];
+    const mint = mints[mintIndex];
+    const userTa = tokenAccounts[userIndex][mintIndex];
+    const vaultTa = vaultTAs[userIndex][mintIndex];
+    const vaultBump = vaultTABumps[userIndex][mintIndex];
+    const locker = lockerPDAs[userIndex];
+
+    const should_go_in_burn_ta = true;
+    const [burnTa, burnBump] = await PublicKey.findProgramAddress(
+      [mint.toBuffer()],
+      program.programId
+    );
+    const tx = await program.methods
+      .deposit(
+        vaultBump,
+        deposit_amount,
+        beforeAmount,
+        burnBump,
+        should_go_in_burn_ta
+      )
+      .accounts({
+        config: configPDA,
+        locker,
+        mint: mint,
+        owner: user.publicKey,
+        admin: providerPk,
+        burnTa,
+        userTa,
+        vaultTa,
+        systemProgram: SystemProgram.programId,
+        tokenProgram: TOKEN_PROGRAM_ID,
+        rent: SYSVAR_RENT_PUBKEY,
+      })
+      .signers([user, payer])
+      .rpc();
+
+    const burnAccount = await provider.connection.getParsedAccountInfo(burnTa);
+    assert.strictEqual(
+      (
+        burnAccount.value.data as any
+      ).parsed.info.tokenAmount.uiAmount.toString(),
+      finalAmount.toString()
+    );
+  });
+
+  it("WithdrawV2 from burnTa: u: 0, m: 0, a: 1", async () => {
+    const userIndex = 0;
+    const mintIndex = 0;
+    const withdrawAmount = new anchor.BN(1);
     const withTransfer = true;
 
-    const { beforeAmount, finalAmount: tempFinalAmount } =
-      await getCheckAmounts(
-        "withdraw",
-        userIndex,
-        mintIndex,
-        withdrawAmount,
-        withTransfer
-      );
+    const { beforeAmount, finalAmount } = await getCheckAmounts(
+      "withdraw",
+      userIndex,
+      mintIndex,
+      withdrawAmount,
+      withTransfer
+    );
     const user = users[userIndex];
     const mint = mints[mintIndex];
     const userTa = tokenAccounts[userIndex][mintIndex];
@@ -548,18 +503,19 @@
       program.programId
     );
 
-    const burnTokenAccountBefore = await provider.connection.getParsedAccountInfo(
+    const burnAccountBefore = await provider.connection.getParsedAccountInfo(
       burnTa
     );
-
-    const finalAmount = tempFinalAmount.sub(missingTokens);
+    const burnTaAmountBefore = (burnAccountBefore.value.data as any).parsed.info
+      .tokenAmount.uiAmount;
+
     const tx = await program.methods
       .withdrawV2(
         vaultBump,
         burn_bump,
         withdrawAmount,
         beforeAmount,
-        finalAmount,
+        finalAmount
       )
       .accounts({
         config: configPDA,
@@ -568,7 +524,7 @@
         admin: providerPk,
         userTa,
         userTaOwner: user.publicKey,
-        vaultTa,
+        vaultTa: burnTa,
         vaultTaOwner: user.publicKey,
         burnTa,
         systemProgram: SystemProgram.programId,
@@ -576,246 +532,15 @@
         associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
         rent: SYSVAR_RENT_PUBKEY,
       })
-      .rpc();
-
-    const burnTokenAccount = await provider.connection.getParsedAccountInfo(
-      burnTa
-    );
-    const vaultAccount = await provider.connection.getParsedAccountInfo(
-      vaultTa
-    );
-
-    const expected = missingTokens.toNumber() + (burnTokenAccountBefore.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount
-    assert.strictEqual(
-      expected.toString(),
-      (burnTokenAccount.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount.toString()
-    );
-    assert.strictEqual(
-      finalAmount.toString(),
-      (vaultAccount.value.data as ParsedAccountData).parsed.info.tokenAmount.uiAmount.toString()
-    );
-    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
-  });
-
-  it("WithdrawV2: withdraw to another user. u: 1, m: 0, a: 1", async () => {
-    const userLockerFromIndex = 0;
-    const userDestIndex = 1;
-    const mintIndex = 0;
-    const withdrawAmount = new anchor.BN(1);
-    const withTransfer = true;
-
-    const { beforeAmount, finalAmount } =
-      await getCheckAmounts(
-        "withdraw",
-        userLockerFromIndex,
-        mintIndex,
-        withdrawAmount,
-        withTransfer
-      );
-    
-    const mint = mints[mintIndex];
-
-    const userFrom = users[userLockerFromIndex];
-    
-    const userDest = users[userDestIndex];
-    const userTa = tokenAccounts[userDestIndex][mintIndex];
-    
-    const vaultBump = vaultTABumps[userLockerFromIndex][mintIndex];
-    const vaultTa = vaultTAs[userLockerFromIndex][mintIndex];
-    const lockerFrom = lockerPDAs[userLockerFromIndex];
-
-    const userTAAmountBefore = new anchor.BN((await getAccount(provider.connection, userTa)).amount.toString());
-
-    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
-      [mint.toBuffer()],
-      program.programId
-    );
-
-    const tx = await program.methods
-      .withdrawV2(
-        vaultBump,
-        burn_bump,
-        withdrawAmount,
-        beforeAmount,
-        finalAmount,
-      )
-      .accounts({
-        config: configPDA,
-        locker: lockerFrom,
-        mint: mint,
-        admin: providerPk,
-        userTa,
-        userTaOwner: userDest.publicKey,
-        vaultTa,
-        vaultTaOwner: userFrom.publicKey,
-        burnTa,
-        systemProgram: SystemProgram.programId,
-        tokenProgram: TOKEN_PROGRAM_ID,
-        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
-        rent: SYSVAR_RENT_PUBKEY,
-      })
-      .rpc();
-
-    const userTAAmount = (await getAccount(provider.connection, userTa)).amount.toString();
-    assert.deepEqual(userTAAmount, withdrawAmount.add(userTAAmountBefore).toString());
-
-    await afterChecks(mintIndex, vaultTa, lockerFrom, finalAmount, mint);
-  });
-
-  it("Withdraw all to close vault ta: u: 0, m: 0, a: 99", async () => {
-    const userIndex = 0;
-    const mintIndex = 0;
-    const withTransfer = true;
-
-    const { beforeAmount: withdrawAmount } = await getCheckAmounts(
-      "withdraw",
-      userIndex,
-      mintIndex,
-      new anchor.BN(0),
-      withTransfer
-    );
-
-    const { beforeAmount, finalAmount } = await getCheckAmounts(
-      "withdraw",
-      userIndex,
-      mintIndex,
-      withdrawAmount,
-      withTransfer
-    );
-
-    const user = users[userIndex];
-    const mint = mints[mintIndex];
-    const userTa = tokenAccounts[userIndex][mintIndex];
-    const vaultBump = vaultTABumps[userIndex][mintIndex];
-    const vaultTa = vaultTAs[userIndex][mintIndex];
-    const locker = lockerPDAs[userIndex];
-
-    const tx = await program.methods
-      .withdraw(
-        vaultBump,
-        withdrawAmount,
-        beforeAmount,
-        finalAmount,
-        withTransfer
-      )
-      .accounts({
-        config: configPDA,
-        locker,
-        mint: mint,
-        owner: user.publicKey,
-        admin: providerPk,
-        userTa,
-        vaultTa,
-        systemProgram: SystemProgram.programId,
-        tokenProgram: TOKEN_PROGRAM_ID,
-        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
-        rent: SYSVAR_RENT_PUBKEY,
-      })
       .signers([user, payer])
       .rpc();
 
-    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
-  });
-
-  it("Deposit to close vault TA: u: 0, m: 0, a: 100", async () => {
-    const userIndex = 0;
-    const mintIndex = 0;
-    const user = users[userIndex];
-    const mint = mints[mintIndex];
-    const userTa = tokenAccounts[userIndex][mintIndex];
-    const vaultTa = vaultTAs[userIndex][mintIndex];
-    const vaultBump = vaultTABumps[userIndex][mintIndex];
-    const locker = lockerPDAs[userIndex];
-
-    const deposit_amount = new anchor.BN((await getAccount(provider.connection, userTa)).amount.toString());
-
-    const { beforeAmount, finalAmount } = await getCheckAmounts(
-      "deposit",
-      userIndex,
-      mintIndex,
-      deposit_amount
-    );
-
-  const vaultAccount = await getAccount(provider.connection, userTa)
-    const tx = await program.methods
-      .deposit(vaultBump, deposit_amount, beforeAmount)
-      .accounts({
-        config: configPDA,
-        locker,
-        mint: mint,
-        owner: user.publicKey,
-        admin: providerPk,
-        userTa,
-        vaultTa,
-        systemProgram: SystemProgram.programId,
-        tokenProgram: TOKEN_PROGRAM_ID,
-        rent: SYSVAR_RENT_PUBKEY,
-      })
-      .signers([user, payer])
-      .rpc();
-
-    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
-  });
-
-  it("WithdrawV2: Withdraw all. u: 0, m: 0, a: 100", async () => {
-    const userIndex = 0;
-    const mintIndex = 0;
-    const withTransfer = true;
-
-    const { beforeAmount: withdrawAmount } = await getCheckAmounts(
-      "withdraw",
-      userIndex,
-      mintIndex,
-      new anchor.BN(0),
-      withTransfer
-    );
-
-    const { beforeAmount, finalAmount } = await getCheckAmounts(
-      "withdraw",
-      userIndex,
-      mintIndex,
-      withdrawAmount,
-      withTransfer
-    );
-
-    const user = users[userIndex];
-    const mint = mints[mintIndex];
-    const userTa = tokenAccounts[userIndex][mintIndex];
-    const vaultBump = vaultTABumps[userIndex][mintIndex];
-    const vaultTa = vaultTAs[userIndex][mintIndex];
-    const locker = lockerPDAs[userIndex];
-
-    const [burnTa, burn_bump] = await PublicKey.findProgramAddress(
-      [mint.toBuffer()],
-      program.programId
-    );
-
-    const tx = await program.methods
-      .withdrawV2(
-        vaultBump,
-        burn_bump,
-        withdrawAmount,
-        beforeAmount,
-        finalAmount,
-      )
-      .accounts({
-        config: configPDA,
-        locker,
-        mint: mint,
-        admin: providerPk,
-        userTa,
-        userTaOwner: user.publicKey,
-        vaultTa,
-        vaultTaOwner: user.publicKey,
-        burnTa,
-        systemProgram: SystemProgram.programId,
-        tokenProgram: TOKEN_PROGRAM_ID,
-        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
-        rent: SYSVAR_RENT_PUBKEY,
-      })
-      .rpc();
-
-    await afterChecks(mintIndex, vaultTa, locker, finalAmount, mint);
+    const burnAccountAfter = await provider.connection.getParsedAccountInfo(
+      burnTa
+    );
+    const burnTaAmountAfter = (burnAccountAfter.value.data as any).parsed.info
+      .tokenAmount.uiAmount;
+    assert.strictEqual(burnTaAmountAfter + 1, burnTaAmountBefore);
   });
 });
 
@@ -838,7 +563,9 @@
     (v) => v.toString() === mints[mintIndex].toString()
   );
   let beforeAmount =
-    lockerMintIndex !== -1 ? lockerAccount.amounts[lockerMintIndex] : new anchor.BN(0);
+    lockerMintIndex !== -1
+      ? lockerAccount.amounts[lockerMintIndex]
+      : new anchor.BN(0);
   const sign = txType == "deposit" ? new anchor.BN(1) : new anchor.BN(-1);
   let finalAmount = withTransfer
     ? beforeAmount.add(sign.mul(withdrawAmount))
@@ -851,7 +578,7 @@
   vaultTa: anchor.web3.PublicKey,
   locker: anchor.web3.PublicKey,
   finalAmount: anchor.BN,
-  mint: string,
+  mint: string
 ): Promise<void> {
   const vaultAccount = await provider.connection.getParsedAccountInfo(vaultTa);
   const lockerAccount = await program.account.locker.fetch(locker);
@@ -859,14 +586,19 @@
     (v) => v.toString() === mints[mintIndex].toString()
   );
 
-  if (finalAmount.toString() !== '0') {
-    assert.strictEqual(lockerAccount.amounts[lockerMintIndex].toString(), finalAmount.toString());
+  if (finalAmount.toString() !== "0") {
+    assert.strictEqual(
+      lockerAccount.amounts[lockerMintIndex].toString(),
+      finalAmount.toString()
+    );
     assert.strictEqual(
       lockerAccount.mints[lockerMintIndex].toString(),
       mint.toString()
     );
     assert.strictEqual(
-      (vaultAccount.value.data as any).parsed.info.tokenAmount.uiAmount.toString(),
+      (
+        vaultAccount.value.data as any
+      ).parsed.info.tokenAmount.uiAmount.toString(),
       finalAmount.toString()
     );
   } else {
================================================================================
