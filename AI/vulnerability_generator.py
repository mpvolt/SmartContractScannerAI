import requests
import csv
import time
import openai
import json
import pandas as pd

client = openai.OpenAI(api_key="")

def generate_text_local(model, prompt):
    # Set up the API endpoint URL
    url = "http://localhost:11434/api/generate"

    print("Processing: " + prompt)

    # Set up the payload dictionary
    payload = {
        "model": model,
        "prompt": "Here's a json object containing a 'code' field with vulnerable solana code, and a 'vulnerabilities' field containing the vulnerability categories. Create new fields for the object called 'secure_code' and 'explanation_of_fix' which contain the fixed code and an explanation of the fix. Then return the object:\n\n" + prompt,
        "stream": False
    }

    # Make the POST request to the API endpoint
    response = requests.post(url, json=payload).json()['response']

    if "```" in response:
        response = response.split("```")[1].strip()

    if "[PYTHON]" in response:
        response = response.split("[PYTHON]")[1].strip()
    
    # Print the response data
    print(response)
    return(response)

def generate_text_gpt(prompt):
    try:
        if prompt:
            print("Prompt: " + prompt)
            response = client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": "You are an AI expert in blockchain security, specializing in Solana smart contracts. Your task is to process an input related to a vulnerability from an audit report. The input will either be a vulnerability description or a category name. Use this list of predefined vulnerability types: \n- Reentrancy\n- Integer Overflow/Underflow\n- Access Control Failure\n- Unchecked External Call\n- Denial of Service (DoS)\n- Front-Running\n- Logic Error\n- Insufficient Validation\n- Signer Authorization\n- Account Data Matching\n- Owner Checks\n- Type Cosplay\n- Initialization\n- Arbitrary CPI\n- Duplicate Mutable Accounts\n- Bump Seed Canonicalization\n- PDA Sharing\n- Closing Accounts\n- Sysvar Address Checking\n- Other (use only if no listed category fits). \n\nIf 'Other' is chosen, suggest a specific new category relevant to Solana smart contracts in brackets, e.g., 'Other (Account Misuse)'."},
                    {"role": "user", "content": f"Analyze this input carefully: '{prompt}'. \n\n1. If the input is a description, identify a matching category and return it. If ambiguous, propose a new category using Other e.g., 'Other (Voter Weight Manipulation)' \n2. If the input matches a category from the list exactly (case-insensitive), create a description for it instead. \n3. Return only a single line of text. "}
                ]
            )
            response = response.choices[0].message.content
            print("Response: ")
            print(response)
            return response
        else:
            return ""
    except Exception as e:
        return f"Error fetching AI explanation: {e}"

def read_vulnerabilities(input_file, output_file):
    with open(input_file, 'r', encoding='utf-8') as f_in, open(output_file, 'w', newline='', encoding='utf-8') as f_out:
        reader = csv.reader(f_in)
        writer = csv.writer(f_out)
        
        # Get the header row
        header = next(reader)

        # # Skip the first 53 rows
        # for _ in range(53):
        #     next(reader)

        # Identify the column indices for "secure_code" and "insecure_code"
        vulnerability_index = header.index("vulnerability")
        description_index = header.index("description")

        # Write the header row only if the output file is empty
        # Check if the file is empty and write the header if it is
        f_out.seek(0, 2)  # Move to the end of the file
        if f_out.tell() == 0:  # If the file is empty, write the header
            writer.writerow(header)
        
        
        for row in reader:
            # Process the values in the "secure_code" and "insecure_code" columns
            if(row[description_index] == ""):
                row[description_index] = generate_text_gpt(row[vulnerability_index])
            elif(row[vulnerability_index] == ""):
                row[vulnerability_index] = generate_text_gpt(row[description_index])
            time.sleep(3)
            
            # Write the updated row to the output file
            print(row)
            writer.writerow(row)
            
def read_json(input_file, output_file):
    with open(input_file, 'r', encoding='utf-8') as f_in, open(output_file, 'w', newline='', encoding='utf-8') as f_out:
        data = json.load(f_in)
        for obj in data:
            newobj = generate_text_gpt(json.dumps(obj))
            json.dump(newobj, f_out)
            # Add a newline character at the end of the object to ensure proper formatting
            f_out.write('\n')
            time.sleep(1)

def read_json(filepath):
    """
    Function to load data from a JSON file.

    Args:
        filepath (str): The path to the JSON file.

    Returns:
        A list of dictionaries, where each dictionary represents an object in the JSON file.
    """
    with open(filepath) as f:
        data = json.load(f)
    return data


# # Read the JSON file into a DataFrame
# df = pd.read_json('solana_cleaned.json')

# # Write the DataFrame to a CSV file
# df.to_csv('output.csv', index=False)


input_file = "vulnerabilities_updated.csv"
output_file = "vulnerabilities_modified.csv"
read_vulnerabilities(input_file, output_file)